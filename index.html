<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini Wallpapers</title>
    <link rel="stylesheet" href="./reset.css" />
    <link rel="stylesheet" href="./app.css" />
  </head>

  <body>
    <header>
      <h1>Minimalist Wallpapers</h1>
    </header>

    <main x-data="miniWallpapers">
      <div id="controlsContainer">
        <div id="tabsContainer">
          <button
            @click="activeTab = 'general'"
            class="tab-button"
            :class="{ active: activeTab === 'general' }"
          >
            General
          </button>
          <button
            @click="activeTab = 'text'"
            class="tab-button"
            :class="{ active: activeTab === 'text' }"
          >
            Text
          </button>
          <button
            @click="activeTab = 'lines'"
            class="tab-button"
            :class="{ active: activeTab === 'lines' }"
          >
            Lines
          </button>
          <button
            @click="activeTab = 'linesEnds'"
            class="tab-button"
            :class="{ active: activeTab === 'linesEnds' }"
          >
            Lines ends
          </button>
        </div>

        <hr />

        <div class="tab" x-show="activeTab === 'general'">
          <div id="deviceSelectContainer" class="input-group">
            <label for="deviceSelect">Device size</label>
            <select id="deviceSelect" x-model="deviceSelect">
              <option value="640x1136">iPhone 4/5 (640x1136)</option>
              <option value="750x1334">iPhone 6/7/8 (750x1334)</option>
              <option value="1080x1920">iPhone 6/7/8 Plus (1080x1920)</option>
              <option value="1125x2436">iPhone X/XS/11 Pro (1125x2436)</option>
              <option value="1242x2688">
                iPhone XS Max/11 Pro Max (1242x2688)
              </option>
              <option value="1170x2532">iPhone 12/13/14 (1170x2532)</option>
              <option value="1284x2778">
                iPhone 12/13/14 Pro Max (1284x2778)
              </option>
              <option value="1290x2796">iPhone 15 Pro Max (1290x2796)</option>
              <option value="2560x1600">MacBook Air 13" (2560x1600)</option>
              <option value="3024x1964">MacBook Pro 14" (3024x1964)</option>
              <option value="3456x2234">MacBook Pro 16" (3456x2234)</option>
            </select>
          </div>

          <div class="input-group-inline">
            <label for="inputBackgroundColor">Background color</label>
            <input
              type="color"
              id="inputBackgroundColor"
              x-model="canvasBackgroundColor"
            />
          </div>
        </div>

        <div class="tab" x-show="activeTab === 'text'">
          <div class="input-group">
            <label for="inputText">Text content</label>
            <input
              type="text"
              id="inputText"
              placeholder="Enter text here"
              x-model="canvasText"
            />
          </div>

          <div class="input-group">
            <label for="inputTextFontSize">Text font size</label>
            <input
              type="range"
              id="inputTextFontSize"
              min="10"
              max="30"
              step="1"
              x-model.number="canvasTextFontSize"
            />
          </div>

          <div class="input-group-inline">
            <span>Font style</span>
            <div id="fontStyleOptions">
              <label
                for="inputTextFontStyleBold"
                style="font-weight: bold"
                :class="{ active: canvasTextFontStyle.includes('bold') }"
                >B</label
              >
              <input
                type="checkbox"
                id="inputTextFontStyleBold"
                value="bold"
                x-model="canvasTextFontStyle"
              />

              <label
                for="inputTextFontStyleItalic"
                style="font-style: italic"
                :class="{ active: canvasTextFontStyle.includes('italic') }"
                >I</label
              >
              <input
                type="checkbox"
                id="inputTextFontStyleItalic"
                value="italic"
                x-model="canvasTextFontStyle"
              />

              <label
                for="inputTextFontStyleUnderline"
                style="text-decoration: underline"
                :class="{ active: canvasTextFontStyle.includes('underline') }"
                >U</label
              >
              <input
                type="checkbox"
                id="inputTextFontStyleUnderline"
                value="underline"
                x-model="canvasTextFontStyle"
              />

              <input
                type="checkbox"
                id="inputTextFontStyleStrikethrough"
                value="line-through"
                x-model="canvasTextFontStyle"
              />
              <label
                for="inputTextFontStyleStrikethrough"
                style="text-decoration: line-through"
                :class="{ active: canvasTextFontStyle.includes('line-through') }"
                >Strikethrough</label
              >
            </div>
          </div>

          <div class="input-group-inline">
            <label for="inputTextFontColor">Font color</label>
            <input
              type="color"
              id="inputTextFontColor"
              x-model="canvasTextFontColor"
            />
          </div>
        </div>

        <div class="tab" x-show="activeTab === 'lines'">
          <div class="input-group">
            <label for="linesNumber"
              >Number of lines: <span x-text="linesNumber"></span
            ></label>
            <input
              type="range"
              id="linesNumber"
              min="1"
              max="25"
              step="2"
              x-model.number="linesNumber"
            />
          </div>

          <div class="input-group">
            <label for="linesHeight">Lines height</label>
            <input
              type="range"
              id="linesHeight"
              min="1"
              max="45"
              x-model.number="linesHeight"
            />
          </div>

          <div class="input-group">
            <label for="linesSpacing">Lines spacing</label>
            <input
              type="range"
              id="linesSpacing"
              min="1"
              max="49"
              x-model.number="linesSpacing"
            />
          </div>

          <div class="input-group">
            <label for="linesWidth">Lines width</label>
            <input
              type="range"
              id="linesWidth"
              min="1"
              max="5"
              step="0.1"
              x-model.number="linesWidth"
            />
          </div>

          <div class="input-group">
            <label for="linesPyramidalShape">Pyramidal shape</label>
            <input
              type="range"
              id="linesPyramidalShape"
              min="-100"
              max="100"
              x-model.number="linesPyramidalShape"
            />
          </div>
        </div>

        <div class="tab" x-show="activeTab === 'linesEnds'">
          <div class="input-group">
            <label for="linesEndsType">Lines ends type</label>
            <select id="linesEndsType" x-model="linesEndsType">
              <option value="none">None</option>
              <option value="arrow">Arrow</option>
              <option value="reverseArrow">Reverse arrow</option>
            </select>
          </div>

          <div class="input-group-inline">
            <label for="linesEndsColor">Lines ends color</label>
            <input type="color" id="linesEndsColor" x-model="linesEndsColor" />
          </div>

          <div class="input-group">
            <label for="linesEndsWidth">Lines ends width</label>
            <input
              type="range"
              id="linesEndsWidth"
              min="1"
              max="5"
              step="0.1"
              x-model.number="linesEndsWidth"
            />
          </div>
        </div>
      </div>

      <div id="canvasContainer">
        <svg
          id="canvas"
          :width="canvasWidth"
          :height="canvasHeight"
          :viewBox="`0 0 ${canvasWidth} ${canvasHeight}`"
          preserveAspectRatio="xMidYMid meet"
        >
          <rect
            :width="canvasWidth"
            :height="canvasHeight"
            :fill="canvasBackgroundColor"
          />

          <text
            id="svgTextCenter"
            x="50%"
            y="50%"
            text-anchor="middle"
            dominant-baseline="middle"
            font-family="'Courier New', Courier, monospace"
            :fill="canvasTextFontColor"
            :font-size="canvasTextFontSize"
            :font-weight="getSvgTextFontWeight()"
            :font-style="getSvgTextFontStyle()"
            :text-decoration="getSvgTextTextDecoration()"
            x-text="canvasText"
          ></text>
          <g id="shapes"></g>

          <defs>
            <marker
              id="topArrowHead"
              refX="10"
              refY="10"
              markerWidth="20"
              markerHeight="20"
              orient="0"
              markerUnits="userSpaceOnUse"
            >
              <polyline
                points="0 0, 10 10, 20 0"
                :stroke="linesEndsColor"
                :stroke-width="linesEndsWidth"
                fill="none"
              />
            </marker>

            <marker
              id="bottomArrowHead"
              refX="10"
              refY="10"
              markerWidth="20"
              markerHeight="20"
              orient="180"
              markerUnits="userSpaceOnUse"
            >
              <polyline
                points="0 0, 10 10, 20 0"
                :stroke="linesEndsColor"
                :stroke-width="linesEndsWidth"
                fill="none"
              />
            </marker>

            <marker
              id="topReverseArrowHead"
              refX="10"
              refY="10"
              markerWidth="20"
              markerHeight="20"
              orient="180"
              markerUnits="userSpaceOnUse"
            >
              <polyline
                points="0 0, 10 10, 20 0"
                :stroke="linesEndsColor"
                :stroke-width="linesEndsWidth"
                fill="none"
              />
            </marker>

            <marker
              id="bottomReverseArrowHead"
              refX="10"
              refY="10"
              markerWidth="20"
              markerHeight="20"
              orient="0"
              markerUnits="userSpaceOnUse"
            >
              <polyline
                points="0 0, 10 10, 20 0"
                :stroke="linesEndsColor"
                :stroke-width="linesEndsWidth"
                fill="none"
              />
            </marker>
          </defs>
        </svg>
      </div>
    </main>

    <script defer src="./alpine.js"></script>

    <script>
      document.addEventListener("alpine:init", () => {
        Alpine.data("miniWallpapers", () => ({
          tabs: ["general", "text", "lines", "linesEnds"],
          activeTab: "general",
          deviceSelect: "640x1136",
          canvasHeight: 1136,
          canvasWidth: 640,
          canvasBackgroundColor: "#ffffff",
          canvasText: "lorem",
          canvasTextFontColor: "#000000",
          canvasTextFontSize: 16,
          canvasTextFontStyle: [],
          linesNumber: 5,
          linesHeight: 20,
          linesSpacing: 20,
          linesWidth: 2,
          linesPyramidalShape: 0,
          linesEndsColor: "#000000",
          linesEndsType: "arrow",
          linesEndsWidth: 2,

          getSvgTextFontStyle() {
            const allowedStyles = ["italic"];
            return this.canvasTextFontStyle
              .filter((style) => allowedStyles.includes(style))
              .join(" ");
          },

          getSvgTextFontWeight() {
            const allowedStyles = ["bold"];
            return this.canvasTextFontStyle
              .filter((style) => allowedStyles.includes(style))
              .join(" ");
          },

          getSvgTextTextDecoration() {
            const allowedStyles = ["underline", "line-through"];
            return this.canvasTextFontStyle
              .filter((style) => allowedStyles.includes(style))
              .join(" ");
          },

          calculateShapeXPositionPercentage(shapeIndex) {
            const farLeftShapeXPositionPercentage = 50 - this.linesSpacing;
            const farRightShapeXPositionPercentage = 50 + this.linesSpacing;
            const shapesXPositionSpan =
              farRightShapeXPositionPercentage -
              farLeftShapeXPositionPercentage;

            return (
              farLeftShapeXPositionPercentage +
              (shapeIndex * shapesXPositionSpan) / (this.linesNumber - 1)
            );
          },

          calculateShapeYPositionPercentage(shapeIndex) {
            const shapeAtTheMiddleIndex = Math.floor(this.linesNumber / 2);
            const numberOfShapesOnEachSideOfTheMiddleShape = Math.floor(
              this.linesNumber / 2
            );
            const shapeYPositionPercentageRelativeToMiddleOne =
              100 -
              (Math.abs(shapeAtTheMiddleIndex - shapeIndex) *
                this.linesPyramidalShape) /
                numberOfShapesOnEachSideOfTheMiddleShape;
            const shapeYPositionPercentage =
              (this.linesHeight * shapeYPositionPercentageRelativeToMiddleOne) /
              100;

            return shapeYPositionPercentage;
          },

          generateShapes() {
            const shapes = [];

            switch (this.linesEndsType) {
              case "arrow":
                topArrowHead = "url(#topArrowHead)";
                bottomArrowHead = "url(#bottomArrowHead)";
                break;
              case "reverseArrow":
                topArrowHead = "url(#topReverseArrowHead)";
                bottomArrowHead = "url(#bottomReverseArrowHead)";
                break;
              default:
                topArrowHead = "none";
                bottomArrowHead = "none";
            }

            if (this.linesNumber === 1) {
              shapes.push(
                `<line x1="50%" y1="0" x2="50%" y2="${this.linesHeight}%" stroke="#000000" stroke-width="${this.linesWidth}" marker-end="${topArrowHead}" />`
              );
              shapes.push(
                `<line x1="50%" y1="100%" x2="50%" y2="${
                  100 - this.linesHeight
                }%" stroke="#000000" stroke-width="${
                  this.linesWidth
                }" marker-end="${bottomArrowHead}" />`
              );
            } else {
              for (let i = 0; i < this.linesNumber; i++) {
                const shapeX = this.calculateShapeXPositionPercentage(i);
                const shapeY = this.calculateShapeYPositionPercentage(i);

                shapes.push(
                  `<line x1="${shapeX}%" y1="0" x2="${shapeX}%" y2="${shapeY}%" stroke="#000000" stroke-width="${this.linesWidth}" marker-end="${topArrowHead}" />`
                );
                shapes.push(
                  `<line x1="${shapeX}%" y1="100%" x2="${shapeX}%" y2="${
                    100 - shapeY
                  }%" stroke="#000000" stroke-width="${
                    this.linesWidth
                  }" marker-end="${bottomArrowHead}" />`
                );
              }
            }

            document.getElementById("shapes").innerHTML = shapes.join("");
          },

          init() {
            this.$watch("deviceSelect", (value) => {
              [this.canvasWidth, this.canvasHeight] = value
                .split("x")
                .map(Number);
            });

            this.$watch("linesNumber", () => {
              this.generateShapes();
            });

            this.$watch("linesHeight", () => {
              this.generateShapes();
            });

            this.$watch("linesSpacing", () => {
              this.generateShapes();
            });

            this.$watch("linesWidth", () => {
              this.generateShapes();
            });

            this.$watch("linesPyramidalShape", () => {
              this.generateShapes();
            });

            this.$watch("linesEndsType", () => {
              this.generateShapes();
            });

            this.$watch("linesEndsWidth", () => {
              this.generateShapes();
            });

            this.generateShapes();
          },
        }));
      });
    </script>
  </body>
</html>
